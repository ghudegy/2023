# ` ` 에디토리얼 

## 들어가기 전에 

대회 이름에 대한 좋은 아이디어가 없어서 대회 이름에 공백 하나만 넣었습니다. 이렇게 했더니 [12906번 문제](https://www.acmicpc.net/problem/12096)처럼 **대회 목록에서 대회 링크를 클릭할 수 없게 되었습니다.** 따라서 대회를 참가하기 위해서는 개발자 도구 등을 통해 대회 링크를 찾거나, BOJ 대회 링크 형식인 `https://www.acmicpc.net/contest/view/` 뒤에 대회 번호인 965를 입력하여 진입해야 했습니다. 대회 진입부터 어려웠기 때문에, 참가자의 편의를 위해 대회 홍보글에 대회 링크를 걸어두었습니다. 

* [문제 출처](https://www.acmicpc.net/category/420)를 클릭하는 것도 어렵게 되었습니다... 
* 문제 번호 역시 좋은 아이디어가 없어서 문제에 할당할 BOJ 번호를 그대로 문제 번호로 사용했습니다. 문제 배점도 문제 번호와 같도록 했습니다. 이로 인해 문제별 배점의 차이가 약간 있었습니다. 
* 문제 **번호의** 순서는 문제를 정할 당시에 등록했던 순서로, 난이도와 큰 관련이 없습니다. 다만 더 많은 사람들이 solved.ac 배경과 뱃지를 얻을 수 있도록, 쉽게 부분 점수를 받을 수 있는 문제를 맨 앞에 배치하기로 하여, 대회 문제 순서는 문제 **번호의 역순**으로 정했습니다. 

## 27907번. The primes contain arbitrarily long arithmetic progressions
_출제자: cozyyg,_
_최고 득점자: - (0분, 27907점)_

문제 제목은 그린-타오 정리를 증명한 [논문](https://arxiv.org/abs/math/0404188)의 제목을 그대로 가져왔습니다. 하지만 문제 지문에서도 언급했듯이 그린-타오 정리는 이 문제를 푸는 데 별 도움을 주지 못합니다. 출력하려는 등차수열의 초항을 $a$, 공차를 $d$, 길이를 $l$이라 합시다. 

### 서브태스크 1, 2 ($n \le 10$)

일단 $d$가 홀수라면 $l \le 2$입니다. 따라서 $d$는 $2$의 배수가 되어야 합니다. 비슷하게 $d$는 $3$, $5$, $7$의 배수가 되어야 합니다. 초항 $a$에 대해 탐색하다 보면 $199 + 210 \cdot k$가 $0 \le k \le 9$일 때 소수라는 사실을 알 수 있습니다. 따라서 $a=199$, $d=210$인 수열을 출력하면 907점을 받을 수 있습니다. 

### 아직 서브태스크 1, 2 ($n \le 27$)

전세계의 많은 사람들(그리고 컴퓨터들)이 소수만으로 이루어진 등차수열을 찾는 노력을 했으며, 2023년 4월 30일까지 발견된 가장 긴 소수 등차수열은 길이가 $27$인 등차수열 $224\,584\,605\,939\,537\,911 + 18\,135\,696\,597\,948\,930 \cdot k$ $(0 \le k \le 26)$입니다.

### 서브태스크 3 ($n \le 30$)

$d$가 $30$ 이하의 모든 소수의 배수여야 한다는 사실을 알 수 있습니다. 그런데 $0$은 모든 수의 배수입니다. $a$를 아무 소수로 잡고 $d=0$으로 합시다. 예제에서 확인할 수 있듯이 등차수열이 꼭 증가할 필요는 없습니다. 

## 27906번. 모자 퍼즐
_출제자: jh05013, cozyyg,_
_최고 득점자: - (0분, 27906점)_

## 27905번. Bækj00n Online RPG
_출제자: kipa00,_
_최고 득점자: - (0분, 27905점)_

## 27904번. 키파-틱택토
_출제자: kipa00,_
_최고 득점자: - (0분, 27904점)_

### 서브태스크 1 

동영상을 전부 볼 필요도 없이, 첫 문장만 들으면 해결할 수 있습니다. 이 문장은 "만일 1행 1열, 2행 3열, 4행 1열에 X가 있고, 4행 2열에 O가 있으면 O가 이긴다"로 요약할 수 있습니다.

주어지는 판은 다음과 같습니다:

- $D=1$이므로 O의 차례입니다.
- X가 1행 1열, 2행 3열과 4행 1열에만 있으므로, 4행 2열은 X가 아닙니다.

따라서 4행 2열이 O라면 최선을 다할 필요도 없이 O의 승리이고, 아니라면 4행 2열을 O로 채우면 어떻게 해도 O의 승리이므로 이 서브태스크는 **O가 최선을 다하면 O가 이기는 판**입니다.

그런데 **첫 단어만 비교한다**는 뜻은 양측이 최선을 다할 때 누가 이기는지 출력하라는 뜻입니다. 모든 테스트 케이스에 대해 `KIPA WINS` 혹은 `KIPA DECLARES A WIN`을 출력하면 이 서브태스크를 맞을 수 있습니다.

### 서브태스크 2

직간접적으로 동영상을 전부 보아야 합니다. 몇 가지 가능한 방법을 소개합니다.

- 동영상을 전부 받아적습니다. 1.5배속, 2배속 등으로 받아적어도 되고, 필요한 정보만 받아적어도 됩니다. 예를 들어 "아니고 4행 2열이 X라면 O가 이겼습니다"에서 필요한 정보는 `42XO`(혹은 구현에 따라 `아니고 42XO`)뿐입니다.
- 유튜브의 자막 기능을 이용합니다. 자막을 복사-붙여넣기한 후, 들으면서 틀린 부분을 바로잡습니다. 모두 입력해야 직성이 풀리신다면 이 방법이 좋을 수 있습니다.
- 자막을 복사-붙여넣기한 후, 일부 변형을 자동수정한 후 확인합니다. 자막이 잘못된 부분은 "아니고 사행사요를 요구라면 x가 이겼습니다" 등 알아들을 수 있는 정도에서의 변형인 경우가 많기 때문에, 이들을 찾아 바꾸기로 모두 수정한 뒤 틀린 부분만 바로잡습니다.
- **FFT를 활용합니다.** 영상을 잘 보다 보면, 같은 구문을 말할 때 어투가 이상하게 비슷한 것을 알 수 있습니다. 따라서, 다음과 같은 방법을 쓸 수 있습니다.
  1. 공백이 충분히 길 때 음성을 나누어 1 249개의 음성을 얻습니다.
  2. 같은 음성 $\{A_{i}\}$와 $\{B_{i}\}$에 대해 다음 식이 상당히 최소화되리라고 기대합니다: $\displaystyle \min_{d} \sum_{i} \left(A_{i} - B_{i+d}\right)^{2}$
    - 시그마 식 안쪽의 전개 $\displaystyle \sum_{i} \left(A_{i} - B_{i+d}\right)^{2} = \sum_{i}A_{i}^{2} + \sum_{i}B_{i}^{2} - 2 \sum_{i} A_{i} B_{i+d}$를 통해, 이 식은 $\displaystyle \max_{d} \sum_{i} A_{i} B_{i+d}$를 구하는 것과 같고, 이는 $A$ 혹은 $B$ 중 한 쪽을 뒤집은 후 FFT를 통해 계산할 수 있습니다.
    - 어차피 제출할 것도 아니므로, FFT는 `numpy`나 `scipy` 등의 라이브러리를 이용합시다.
  3. 계산된 전체 식을 음성의 길이인 $N$으로 나눈 평균값을 보면, **적절한 기준점이 반드시 보입니다**. 이 위치를 기준으로 같은 음성과 다른 음성을 나누어 107개의 분류를 얻습니다. 이들의 전체 길이는 8분 정도입니다!

FFT를 활용한 방법과 자막을 활용한 방법을 합치면 청력 손실이 있어도 전체 스크립트를 알아낼 수 있음을 확인했습니다.

이들 방법을 활용하여 얻은 스크립트를 통해, 16개 칸이 모두 채워진 경우에 대해 어느 쪽이 승리했는지를 판단하여 `KIPA WINS`나 `HAVANA WINS`를 적절히 출력해 주면 됩니다.

### 서브태스크 3

현재 상황이 어느 한쪽의 승리 선언 조건을 만족하는지 판단해야 합니다. 이를 위해 불완전한 판으로 승리 조건을 파고들어가는 방법을 사용합니다.

- 판단을 해야 하는 칸이 이미 채워져 있으면, `if`와 `else` 중 어디로 가야 하는지를 정할 수 있습니다.
- 채워져 있지 않으면, 몇 가지 가능성이 있습니다.
  - 결정된 칸 중 `O`가 8개라면, 판단해야 하는 칸은 `X`로 결정되어야 합니다. 이렇다면 칸이 이미 채워진 경우로 환원됩니다.
  - 반대로 결정된 칸 중 `X`가 8개라면, 판단해야 하는 칸은 `O`로 결정되어야 합니다. 마찬가지로 칸이 이미 채워져 있다고 생각할 수 있습니다.
  - 둘 다 아니라면 그 칸은 `O`가 되는 것과 `X`가 되는 것이 모두 가능합니다. 칸을 각각 해당하는 문자열로 채우고, 양쪽을 동시에 탐색합니다.

끝까지 갔을 때, 최종적으로 승자가 결정된 모든 노드가 `O`이면 `KIPA DECLARES A WIN`를, `X`이면 `HAVANA DECLARES A WIN`을 출력하면 됩니다. 둘 다 아니라면, 이 서브태스크에서는 승리 선언을 할 수 없는 경우를 구분하지 않으므로, `KIPA WINS`와 `HAVANA WINS` 중 아무거나 하나를 출력하면 됩니다.

이때, 모든 칸이 다 채워진 경우에 주의하세요. 이 경우는 (당연하게) 탐색한 모든 노드가 같은 승자를 지시하지만, 정답이 `* DECLARES A WIN`이 아니고 `* WINS` 꼴입니다.

시간 복잡도는 트리의 노드 개수를 $M = 2023$이라 할 때 $\mathcal{O}(TM)$입니다.

### 서브태스크 4

일반적인, "최선을 다할 때 승리하는 사람을 찾는" 방법을 이용하면 됩니다. 다음과 같은 규칙입니다. (P는 키파 혹은 아바나입니다. 원칙대로라면 양 경우를 모두 써야 하지만 귀찮으므로 P로 쓰겠습니다.)

- 열여섯 개의 칸이 모두 채워진 경우, 일단 승리 조건에 따라 **승리를 선언한다고** 생각합니다.
- 칸이 조금씩 덜 채워진 경우를 생각하며,
  - 현재 차례인 사람이 어떤 칸에 두든 P가 승리를 선언한다면, P가 승리를 선언합니다.
  - 현재 차례인 사람이 어떤 칸에 두든 P가 [승리를 선언하거나 이긴다면], P가 이깁니다.
  - 아니고 현재 차례인 사람이 P이며 P가 이기는 칸이 존재한다면, P가 이깁니다. 그렇지 않으면 P가 아닌 사람이 이깁니다.

서브태스크 3에서와 마찬가지로, 열여섯 개의 칸이 모두 채워진 다음에는 출력을 조심해야 합니다: `* DECLARES A WIN`이 아니고 `* WINS`를 출력해야 합니다.

### 서브태스크 5

## 27903번. 인생
_출제자: havana723,_
_최고 득점자: - (0분, 27903점)_

## 27902번. CVE: Life is Way Too Short
_출제자: jh05013,_
_최고 득점자: - (0분, 27902점)_

> Bigint's really feel like a neat computer science toy most of the time. We've got them, but what actually uses integers larger than 64 or 128 bits?

2020년에 1,000,000 자리 이상의 정수를 파싱하면 제곱 시간 알고리즘으로 인해 매우 오래 걸린다는 점이 보안 결함 목록(CVE)에 등록되었다. 그로부터 4년 후인 2022년, 파이썬이 긴급 패치되면서 4,300 자리보다 긴 정수를 파싱하려고 하면 오류를 내게 되었고, 이는 당시 큰 파장과 논란을 불러일으켰다.

이 제한을 해제하려면 `sys.set_int_max_str_digits()`을 사용해야 한다.

제목과 지문에 언급된 `CVE`, `4300`, `하위 호환성` 등의 키워드는 모두 이 사태에 대한 레퍼런스이다. 출제자도 과거에 몇 번 언급한 내용이기 때문에, 형평성을 위해 예제 2로부터 무언가 문제가 있음을 유추하게 하고, 관련 정보를 쉽게 찾을 수 있도록 지문을 작성하였다.

BOJ에서는 (이 문제를 제외하고) 이 제한을 기본적으로 해제하기 때문에, 큰 수 A+B 등의 문제에 재채점이 진행되면서 대부분의 코드가 런타임 에러로 바뀌게 되는 일은 볼 수 없게 되었다.

관련 링크:

- [CVE-2020-10735](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-10735)
- [cpython issue #95778: CVE-2020-10735: Prevent DoS by large int<->str conversions](https://github.com/python/cpython/issues/95778)
- [Python doc: Integer string conversion length limitation](https://docs.python.org/3.10/library/stdtypes.html#int-max-str-digits)
- [Int/str conversions broken in latest Python bugfix releases](https://discuss.python.org/t/int-str-conversions-broken-in-latest-python-bugfix-releases/18889)
- [sympy issue #24033: int/str conversions broken by latest CPython bugfix releases](https://github.com/sympy/sympy/issues/24033)
- [A Python security fix breaks (some) bignums](https://lwn.net/Articles/907572/)
- [cpython issue #96834: FAQ for CVE-2020-10735](https://github.com/python/cpython/issues/96834)

## 27901번. 사면수와 삼현수
_출제자: jh05013,_
_최고 득점자: - (0분, 27901점)_

## 27900번. 4차 산업 혁명 2
_출제자: cozyyg,_
_최고 득점자: - (0분, 27900점)_

[Connect Four](https://en.wikipedia.org/wiki/Connect_Four)는 1974년에 출시되어 많은 연구가 이루어졌으며, 1988년에 먼저 플레이하는 사람에게 필승전략이 있음이 증명되었습니다. 놀랍게도 두 플레이어가 모두 최선을 다한다면, $41$번째 수, 즉 먼저 플레이하는 사람의 마지막 수에 게임이 끝나게 됩니다. 따라서 최선의 수를 $21$번 반환해야만 만점을 받을 수 있었습니다. 

### 40점 (모든 테스트 케이스에서 $n = 3$)

`next_move` 함수가 항상 $4$를 반환하도록 하면 40점을 받습니다. $5$번째 수까지는 가운데에 말을 놓는 것이 유일한 최선의 수이기 때문입니다.

### 풀이 1

채점기가 어떤 수를 두었는지 알아내기 위해 다음과 같은 방법을 사용할 수 있습니다. 

* 채점기가 둘 수 있는 최선의 수 $a_i$마다, 이후에 플레이어가 두어야 할 최선의 수 중 하나를 $b_i$로 정합니다. 
* $a_1$을 두었을 때는 $b_1$을, $a_2$를 두었을 때는 $0$을, $a_3$를 두었을 때는 $-1$을 반환하는 등의 방식을 이용하면, 채점기가 어떤 수를 두었는지에 따라 다른 점수가 나오게 됩니다. 이 점수로부터 정보를 얻어내 채점기가 둔 수를 알아낼 수 있습니다. 
* 이 과정을 게임이 끝날 때까지 반복합니다. 

각 테스트 케이스마다 최악의 경우 각 수마다 $2$번씩 제출해야 합니다. 따라서 최대 $21 \times 2 \times 10 = 420$번의 제출 안에 문제를 해결할 수 있습니다. 여러 케이스를 병렬적으로 처리하면 제출 횟수를 단축할 수 있지만, 점수의 합이 어떻게 나왔을지에 대한 knapsack 문제를 풀어야 합니다. 

### 풀이 2

채점기가 최선의 수를 두는 모든 경우를 처리한다면 시행착오 없이 문제를 해결할 수 있습니다. 출제자는 다음과 같은 방법으로 그러한 코드를 만들었습니다. 

* [이 블로그](http://blog.gamesolver.org/)의 글에 첨부된 소스 코드를 다운로드합니다. 
* 초기 상태부터 시작해서 최선의 수로 가능한 상태들을 DFS로 방문하도록 소스 코드를 수정합니다. 
    -  방문할 때 후공의 수는 모두 방문해야 하지만, 선공의 수는 하나만 골라서 방문하면 됩니다. 
* 각 상태마다 최선의 수를 비트마스크로 저장합니다. 예를 들어 최선의 수가 $2$, $4$, $7$이라면 $2^1 + 2^3 + 2^6 = 74$를 저장합니다. 
* 이제 이렇게 만든 (상태 문자열, 비트마스크)의 쌍이 저장된 배열을 하드코딩하면 됩니다. 

다만 상태의 개수가 많아서 이대로는 소스 코드 길이 제한에 걸립니다. 이를 해결하기 위해 두 가지 최적화 과정을 거칩니다.

* 선공의 수를 고를 때 좋은 휴리스틱을 사용하거나 처음 몇 개의 수를 수동으로 선택합니다. 
* 상태 문자열을 저장할 필요가 없습니다. DFS를 똑같이 짠다면 비트마스크 값만으로도 방문하는 상태의 정보를 완전히 복원할 수 있습니다.

이렇게 했을 때 대략 $200\,000 \times 7 = 1\,400\,000$ 비트 정도의 정보량이 나왔고, base64 인코딩을 이용하여 문제를 푸는 $260\,000$ 바이트 정도 길이의 코드를 만들 수 있었습니다.

### Challenge

채점기가 최선의 수를 두지 않는다 해도 문제를 풀 수 있을까요? 시간이 충분히 많다면 가능하겠지만, 빠른 시간 안에 답을 찾아낼 수 있을까요? 
